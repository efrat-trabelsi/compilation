%{
#define INT_NUM 300
#define FLOAT_NUM 301
#define ID 302

// keywords
#define BREAK 305
#define CASE 306
#define DEFAULT 307
#define ELSE 308
#define FLOAT 309
#define IF 310
#define INPUT 311
#define INT 312
#define OUTPUT 313
#define SWITCH 314
#define WHILE 315

// operators
#define RELOP 330
#define ADDOP 331
#define MULOP 332
#define OR 333
#define AND 334
#define NOT 335
#define CAST 336

enum operator {PLUS, MINUS, MUL, DIV, EQ, NE, LT, GT, GE, LE };

union {
  int ival;
  float fval;
  char name [30];
  enum operator op;
  int typ;
} yylval;

#include <stdlib.h>

extern int atoi(const char *);
extern double atof(const char *);
%}

%option noyywrap

%option yylineno  // use this var!!!

%x STAR_COMMENT

%%

[0-9]+			{ yylval.ival = atoi(yytext); return INT_NUM; }
[0-9]+\.[0-9]+	{ yylval.fval = atof(yytext); return FLOAT_NUM; }

"break"		{ return BREAK; }
"case"		{ return CASE; }
"default"	{ return DEFAULT; }
"else"		{ return ELSE; }
"float"		{ return FLOAT; }
"if"		{ return IF; }
"input"		{ return INPUT; }
"int"		{ return INT; }
"output"	{ return OUTPUT; }
"switch"	{ return SWITCH; }
"while"		{ return WHILE;}

"("		{ return '('; }
")"		{ return ')'; }
"{"		{ return '{'; }
"}"		{ return '}'; }
","		{ return ','; }
":"		{ return ':'; }
";"		{ return ';'; }
"="		{ return '='; }

"=="	{ yylval.op = EQ; return RELOP; }
"!="	{ yylval.op = NE; return RELOP; }
"<"		{ yylval.op = LT; return RELOP; }
">"		{ yylval.op = GT; return RELOP; }
">="	{ yylval.op = GE; return RELOP; }
"<="	{ yylval.op = LE; return RELOP; }
"+"		{ yylval.op = PLUS;	return ADDOP; }
"-"		{ yylval.op = MINUS; return ADDOP; }
"*"		{ yylval.op = MUL; return MULOP; }
"/"		{ yylval.op = DIV; return MULOP; }
"||"	{ return OR; }
"&&"	{ return AND; }
"!"		{ return NOT; }

"cast<int>"		{ yylval.typ = INT; return CAST; }
"cast<float>"	{ yylval.typ = FLOAT; return CAST; }

[a-zA-Z][a-zA-Z0-9]*	{ strcpy(yylval.name, yytext); return ID; }

[\t\r ]+  { /* skip white space */ }

[\n]+       { line += yyleng; /* line += strlen(yytext); */ }
 				
"/*"  { BEGIN(STAR_COMMENT); }
<STAR_COMMENT>{
[^*\n]+		{ /* skip chars in comment */ }
\n     		{ line++; }
"*"			{ /* skip a '*'. (if the '*' is followed by a slash -- the next rule will handle it) */ } 
"*/"		{ BEGIN(0); }
} // end STAR_COMMENT

.		{ printf ("line %d: unrecognized token %c(%x)\n", 
                               line, yytext[0], yytext[0]); }

%%

const char* get_op_name(enum operator op) {
    switch(op) {
        case EQ: return "EQ";
        case NE: return "NE";
        case LT: return "LT";
        case GT: return "GT";
        case GE: return "GE";
        case LE: return "LE";
		
		case PLUS: return "PLUS";
		case MINUS: return "MINUS";
		
		case MUL: return "MUL";
		case DIV: return "DIV";
		
        default: return "UNKNOWN";
    }
}

int main(int argc, char **argv)
{
   extern FILE *yyin;
   int token;

   if (argc != 2) {
      printf("Usage: %s <input file name>\n", argv[0]);
      exit(1);
   }

   yyin = fopen(argv[1], "r");
   
   printf("token\t\tlexeme\t\tattribute\n");
   printf("-----\t\t------\t\t---------\n");
   
   while ((token = yylex()) != 0)
   {
		switch(token) {
			case INT_NUM:
				printf("INT_NUM %d\n", yylval.ival);
				break;
			case FLOAT_NUM:
				printf("FLOAT_NUM %f\n", yylval.fval);
				break;
			case ID:
				printf("ID\t\t%s\t\t%s\n", yytext, yylval.name);
				break;
			
			case BREAK:
				printf("BREAK\t\t%s\n", yytext);
				break;
			case CASE:
				printf("CASE\t\t%s\n", yytext);
				break;
			case DEFAULT:
				printf("DEFAULT\t\t%s\n", yytext);
				break;
			case ELSE:
				printf("ELSE\t\t%s\n", yytext);
				break;
			case FLOAT:
				printf("FLOAT\t\t%s\n", yytext);
				break;
			case IF:
				printf("IF\t\t%s\n", yytext);
				break;
			case INPUT:
				printf("INPUT\t\t%s\n", yytext);
				break;
			case INT:
				printf("INT\t\t%s\n", yytext);
				break;
			case OUTPUT:
				printf("OUTPUT\t\t%s\n", yytext);
				break;
			case SWITCH:
				printf("SWITCH\t\t%s\n", yytext);
				break;
			case WHILE:
				printf("WHILE\t\t%s\n", yytext);
				break;

			case '(':
				printf("(\t\t%s\n", yytext);
				break;
			case ')':
				printf(")\t\t%s\n", yytext);
				break;
			case '{':
				printf("{\t\t%s\n", yytext);
				break;
			case '}':
				printf("}\t\t%s\n", yytext);
				break;
			case ',':
				printf(",\t\t%s\n", yytext);
				break;
			case ':':
				printf(":\t\t%s\n", yytext);
				break;
			case ';':
				printf(";\t\t%s\n", yytext);
				break;
			case '=':
				printf("=\t\t%s\n", yytext);
				break;
			
			case RELOP:
				printf("RELOP\t\t%s\t\t%s\n", yytext, get_op_name(yylval.op));
				break;
			case ADDOP:
				printf("ADDOP\t\t%s\t\t%s\n", yytext, get_op_name(yylval.op));
				break;
			case MULOP:
				printf("MULOP\t\t%s\t\t%s\n", yytext, get_op_name(yylval.op));
				break;
			case OR:
				printf("OR\t\t%s\n", yytext);
				break;
			case AND:
				printf("AND\t\t%s\n", yytext);
				break;
			case NOT:
				printf("NOT\t\t%s\n", yytext);
				break;
			case CAST:
				const char *typeName = (yylval.typ == INT) ? "INT" : "FLOAT";
				printf("CAST\t\t%s\t\t%s\n", yytext, typeName);
				break;
			
			default:
				printf("ERROR: unrecognized character\n");
				exit(1);
		}
	}
	fclose(yyin);
	exit(0);
}

