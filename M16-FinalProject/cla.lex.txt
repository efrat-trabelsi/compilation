%{

#include "cpl.tab.h"  // Generated by bison

extern int atoi(const char *);
extern double atof(const char *);

int line = 1;

%}

%option noyywrap
%option yylineno

%x STAR_COMMENT

%%

[0-9]+			{ yylval.num_val.ival = atoi(yytext); yylval.num_val.type = INT; return NUM; }
[0-9]+\.[0-9]*	{ yylval.num_val.fval = atof(yytext); yylval.num_val.type = FLOAT; return NUM; }

"break"		{ return BREAK; }
"case"		{ return CASE; }
"default"	{ return DEFAULT; }
"else"		{ return ELSE; }
"float"		{ return FLOAT; }
"if"		{ return IF; }
"input"		{ return INPUT; }
"int"		{ return INT; }
"output"	{ return OUTPUT; }
"switch"	{ return SWITCH; }
"while"		{ return WHILE; }

"("		{ return '('; }
")"		{ return ')'; }
"{"		{ return '{'; }
"}"		{ return '}'; }
","		{ return ','; }
":"		{ return ':'; }
";"		{ return ';'; }
"="		{ return '='; }

"=="	{ yylval.op = EQ; return RELOP; }
"!="	{ yylval.op = NE; return RELOP; }
"<"		{ yylval.op = LT; return RELOP; }
">"		{ yylval.op = GT; return RELOP; }
">="	{ yylval.op = GE; return RELOP; }
"<="	{ yylval.op = LE; return RELOP; }
"+"		{ yylval.op = PLUS; return ADDOP; }
"-"		{ yylval.op = MINUS; return ADDOP; }
"*"		{ yylval.op = MUL; return MULOP; }
"/"		{ yylval.op = DIV; return MULOP; }
"||"	{ return OR; }
"&&"	{ return AND; }
"!"		{ return NOT; }

"cast<int>"		{ yylval.cast_type = INT; return CAST; }
"cast<float>"	{ yylval.cast_type = FLOAT; return CAST; }

[a-zA-Z][a-zA-Z0-9]*	{ strcpy(yylval.name, yytext); return ID; }

[\t\r ]+  { /* skip white space */ }

[\n]+       { line += yyleng; /* line += strlen(yytext); */ }
 				
"/*"  { BEGIN(STAR_COMMENT); }
<STAR_COMMENT>{
[^*\n]+		{ /* skip chars in comment */ }
\n     		{ line++; }
"*"			{ /* skip a '*'. (if the '*' is followed by a slash -- the next rule will handle it) */ } 
"*/"		{ BEGIN(0); }
} // end STAR_COMMENT

.		{ 
    fprintf(stderr, "line %d: unrecognized token %c(%x)\n", 
            line, yytext[0], yytext[0]); 
}

%%
