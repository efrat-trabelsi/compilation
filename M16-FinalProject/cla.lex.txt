%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INT_NUM 300
#define FLOAT_NUM 301
#define ID 302

// keywords
#define BREAK 305
#define CASE 306
#define DEFAULT 307
#define ELSE 308
#define FLOAT 309
#define IF 310
#define INPUT 311
#define INT 312
#define OUTPUT 313
#define SWITCH 314
#define WHILE 315

// operators
#define RELOP 330
#define ADDOP 331
#define MULOP 332
#define OR 333
#define AND 334
#define NOT 335
#define CAST 336

enum operator {PLUS, MINUS, MUL, DIV, EQ, NE, LT, GT, GE, LE };

union {
  int ival;
  float fval;
  char name[30];
  enum operator op;
  int typ;
} yylval;

extern int atoi(const char *);
extern double atof(const char *);

int line = 1;
FILE *output_file;

%}

%option noyywrap
%option yylineno

%x STAR_COMMENT

%%

[0-9]+			{ yylval.ival = atoi(yytext); return INT_NUM; }
[0-9]+\.[0-9]*	{ yylval.fval = atof(yytext); return FLOAT_NUM; }

"break"		{ return BREAK; }
"case"		{ return CASE; }
"default"	{ return DEFAULT; }
"else"		{ return ELSE; }
"float"		{ return FLOAT; }
"if"		{ return IF; }
"input"		{ return INPUT; }
"int"		{ return INT; }
"output"	{ return OUTPUT; }
"switch"	{ return SWITCH; }
"while"		{ return WHILE; }

"("		{ return '('; }
")"		{ return ')'; }
"{"		{ return '{'; }
"}"		{ return '}'; }
","		{ return ','; }
":"		{ return ':'; }
";"		{ return ';'; }
"="		{ return '='; }

"=="	{ yylval.op = EQ; return RELOP; }
"!="	{ yylval.op = NE; return RELOP; }
"<"		{ yylval.op = LT; return RELOP; }
">"		{ yylval.op = GT; return RELOP; }
">="	{ yylval.op = GE; return RELOP; }
"<="	{ yylval.op = LE; return RELOP; }
"+"		{ yylval.op = PLUS; return ADDOP; }
"-"		{ yylval.op = MINUS; return ADDOP; }
"*"		{ yylval.op = MUL; return MULOP; }
"/"		{ yylval.op = DIV; return MULOP; }
"||"	{ return OR; }
"&&"	{ return AND; }
"!"		{ return NOT; }

"cast<int>"		{ yylval.typ = INT; return CAST; }
"cast<float>"	{ yylval.typ = FLOAT; return CAST; }

[a-zA-Z][a-zA-Z0-9]*	{ strcpy(yylval.name, yytext); return ID; }

[\t\r ]+  { /* skip white space */ }

[\n]+       { line += yyleng; /* line += strlen(yytext); */ }
 				
"/*"  { BEGIN(STAR_COMMENT); }
<STAR_COMMENT>{
[^*\n]+		{ /* skip chars in comment */ }
\n     		{ line++; }
"*"			{ /* skip a '*'. (if the '*' is followed by a slash -- the next rule will handle it) */ } 
"*/"		{ BEGIN(0); }
} // end STAR_COMMENT

.		{ 
    fprintf(stderr, "line %d: unrecognized token %c(%x)\n", 
            line, yytext[0], yytext[0]); 
}

%%

const char* get_op_name(enum operator op) {
    switch(op) {
		case EQ: return "EQ";
		case NE: return "NE";
		case LT: return "LT";
		case GT: return "GT";
		case GE: return "GE";
		case LE: return "LE";
		
		case PLUS: return "PLUS";
		case MINUS: return "MINUS";
		
		case MUL: return "MUL";
		case DIV: return "DIV";
		
		default: return "UNKNOWN";
    }
}

void print_token_header()
{
	printf("token\t\tlexeme\t\tattribute\n");
	printf("-----\t\t------\t\t---------\n");
	fprintf(output_file, "token\t\tlexeme\t\tattribute\n");
	fprintf(output_file, "-----\t\t------\t\t---------\n");
}

void print_token_info(const char* token_name, const char* lexeme, const char* attribute)
{
	if (attribute) {
		printf("%s\t\t%s\t\t%s\n", token_name, lexeme, attribute);
		fprintf(output_file, "%s\t\t%s\t\t%s\n", token_name, lexeme, attribute);
	} else {
		printf("%s\t\t%s\n", token_name, lexeme);
		fprintf(output_file, "%s\t\t%s\n", token_name, lexeme);
	}
}

int main(int argc, char **argv)
{
	extern FILE *yyin;
	int token;
	char output_filename[256];
	char *ext_start ;
	const char *student_signature = "CPL Lexical Analyzer - Efrat Trabelsi\n\n";
	
	// Print student signature
	fputs(student_signature, stderr);
	
	if (argc != 2) {
		fprintf(stderr, "Usage: %s <input file name>\n", argv[0]);
		exit(1);
	}

	// Check file extension
	if (strlen(argv[1]) < 4 || strcmp(argv[1] + strlen(argv[1]) - 3, ".ou") != 0) {
		fprintf(stderr, "Error: Input file must have .ou extension\n");
		exit(1);
	}
	
	// Open input file
	yyin = fopen(argv[1], "r");
	if (!yyin) {
		fprintf(stderr, "Error: Cannot open input file %s\n", argv[1]);
		exit(1);
	}
	
	// Create output filename with .tok extension
	strcpy(output_filename, argv[1]);
	ext_start = strrchr(output_filename, '.');
	if (ext_start) {
		strcpy(ext_start, ".tok");
	}
	
	// Open output file
	output_file = fopen(output_filename, "w");
	if (!output_file) {
		fprintf(stderr, "Error: Cannot create output file %s\n", output_filename);
		fclose(yyin);
		exit(1);
	}
	
	// Print signature to output file
	fputs(student_signature, output_file);
	
	print_token_header();
	
	while ((token = yylex()) != 0) {
		switch(token) {
			case INT_NUM:
				{
					char attr[20];
					sprintf(attr, "%d", yylval.ival);
					print_token_info("INT_NUM", yytext, attr);
				}
				break;
			case FLOAT_NUM:
				{
					char attr[20];
					sprintf(attr, "%f", yylval.fval);
					print_token_info("FLOAT_NUM", yytext, attr);
				}
				break;
			case ID:
				print_token_info("ID", yytext, yylval.name);
				break;
			
			case BREAK:
				print_token_info("BREAK", yytext, NULL);
				break;
			case CASE:
				print_token_info("CASE", yytext, NULL);
				break;
			case DEFAULT:
				print_token_info("DEFAULT", yytext, NULL);
				break;
			case ELSE:
				print_token_info("ELSE", yytext, NULL);
				break;
			case FLOAT:
				print_token_info("FLOAT", yytext, NULL);
				break;
			case IF:
				print_token_info("IF", yytext, NULL);
				break;
			case INPUT:
				print_token_info("INPUT", yytext, NULL);
				break;
			case INT:
				print_token_info("INT", yytext, NULL);
				break;
			case OUTPUT:
				print_token_info("OUTPUT", yytext, NULL);
				break;
			case SWITCH:
				print_token_info("SWITCH", yytext, NULL);
				break;
			case WHILE:
				print_token_info("WHILE", yytext, NULL);
				break;
			
			case '(':
				print_token_info("(", yytext, NULL);
				break;
			case ')':
				print_token_info(")", yytext, NULL);
				break;
			case '{':
				print_token_info("{", yytext, NULL);
				break;
			case '}':
				print_token_info("}", yytext, NULL);
				break;
			case ',':
				print_token_info(",", yytext, NULL);
				break;
			case ':':
				print_token_info(":", yytext, NULL);
				break;
			case ';':
				print_token_info(";", yytext, NULL);
				break;
			case '=':
				print_token_info("=", yytext, NULL);
				break;
			
			case RELOP:
				print_token_info("RELOP", yytext, get_op_name(yylval.op));
				break;
			case ADDOP:
				print_token_info("ADDOP", yytext, get_op_name(yylval.op));
				break;
			case MULOP:
				print_token_info("MULOP", yytext, get_op_name(yylval.op));
				break;
			case OR:
				print_token_info("OR", yytext, NULL);
				break;
			case AND:
				print_token_info("AND", yytext, NULL);
				break;
			case NOT:
				print_token_info("NOT", yytext, NULL);
				break;
			case CAST:
				{
					const char *typeName = (yylval.typ == INT) ? "INT" : "FLOAT";
					print_token_info("CAST", yytext, typeName);
				}
				break;
			
			default:
				fprintf(stderr, "ERROR: unrecognized token type %d\n", token);
				break;
		}
	}
	
	fclose(yyin);
	fclose(output_file);
	return 0;
}
